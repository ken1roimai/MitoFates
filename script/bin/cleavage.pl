#!/usr/bin/perl
#  Author:  Yoshinori Fukasawa
#  Organizations:  CBRC, AIST
#  Copyright (C) 2014, Yoshinori Fukasawa, All rights reserved.
#  Creation Date:  2014/7/8
#  Modified Date:  2014/8/28
#    --Changed usage of temp dir: from /tmp to somewhere automatically generated by tempdir.
#    --Modified the comment for svm_classify()
#    --Added POD usage and help option.
#  Modified Date: 2014/10/23 (Optimized speed).
#    --Dirichlet posterior calc is the most time consuming, so coded it in C with help of Inline module.
#    --Making Prior struct at each cleavage candidate (too many times), so calc it at first.
#    --Deleted calling for an unused subroutine: "MitoFatesPWMUtil::charge_around_Cleavage"
#    --Fixed a bug for plant region extension.
#    --Removed unused options for development: adjust and plantWindow.
#  Modified Data: 2014/12/22 (Fixed a bug).
#    --Fixed a bug relevant to overwriting of option variables. 

BEGIN{
    use FindBin qw ($Bin);
    use lib "$Bin/modules";
}

use strict;
use warnings;
use diagnostics;
use Pod::Usage 'pod2usage';
use Getopt::Long;
use Carp;

use DirichletRegulator_fast;
use MitoFatesPWM;
use MitoFatesPWMUtil;

use File::Temp qw/tempfile tempdir/;
use vars qw(%svm);

my $opt_help    = 0;
my $opt_man     = 0;
my $opt_plant   = 0;
my $opt_mature  = 0;
my $opt_metazoa = 0;
my $opt_gamma   = '';
my $opt_svm     = '';
my $intermediate_point = 4;
my $opt_slide = 0;
my $length = 100;
my $aminoAcids = 'ACDEFGHIKLMNPQRSTVWY'; # Amino acids letters use for regexp.

GetOptions(
    'help'          => \$opt_help,
    'man'           => \$opt_man,
    'plant'         => \$opt_plant,
    'metazoa'       => \$opt_metazoa,
    'fungi'         => \$opt_mature,
    'gamma'         => \$opt_gamma,
    'svm'           => \$opt_svm,
    'sliding'       => \$opt_slide,
);

############################################################################################################
# Help

$opt_help && pod2usage( -verbose => 1);
$opt_man  && pod2usage( -verbose => 2);

############################################################################################################
# Paths for required files
my $priorPath    = "$Bin/Setting/recode3.20comp";
my $profile      = "$Bin/Setting/PWMs.pwm";
my $svmModelPath = "$Bin/Setting/Cleavage.model";

############################################################################################################
#Read pwm from the path.
my $matrix    = readMatrix($profile);
my $fastaPath = shift @ARGV;

pod2usage(-verbose=>1) unless $fastaPath;

############################################################################################################
# Distribution of length related oprions

# Get Parameters of Gamma Probability Density Function from given file path. (--gamma option)
# This option takes parameters for MPP cleavage site.
# I used mixtools package of R to estimate parameters of Gammma mixture.
my @Gamma_params if($opt_gamma);
if($opt_gamma && !$opt_plant && !$opt_metazoa){
    $opt_gamma    = "$Bin/Setting/GammaParams.txt";
    @Gamma_params = &ret_gammaParams($opt_gamma);
} elsif ($opt_gamma && $opt_plant && !$opt_metazoa){
    $opt_gamma    = "$Bin/Setting/GammaParamsPlant.txt";
    @Gamma_params = &ret_gammaParams($opt_gamma);
    $length = 120;
} elsif ($opt_gamma && !$opt_plant && $opt_metazoa){
    $opt_gamma    = "$Bin/Setting/GammaParamsMetazoa.txt";
    @Gamma_params = &ret_gammaParams($opt_gamma);
}

############################################################################################################
# Threshold for each PWMs. Do not change if there is no specific reason.

my ($thresholdOct1, $thresholdIcp55, $thresholdIcp55Like)
    = (5.1, 1.8, 0.1);

############################################################################################################
# SVM confirmation

if($opt_svm && !$opt_gamma){
    print STDERR "==\tError: Use --svm option with --gamma option.\n";
    exit(1);
}

my $struct;
if($opt_svm){
    $struct = DirichletParser($priorPath);
}

############################################################################################################
# Intermediate protease option confirmation
my $count_int = 0;
$count_int++ if($opt_plant);
$count_int++ if($opt_mature);
$count_int++ if($opt_metazoa);

if($count_int > 1){
    print STDERR "==\tError: --fungi, --metazoa and --plant options are mutually exclusive.\n";
    exit(1);
} elsif($count_int == 0){
    print STDERR "==\tError: Choose one of --fungi, --metazoa or --plant.\n";
    exit(1);
}

############################################################################################################
# Main

# Get a query fasta.
open my $fastain, "<", $fastaPath || die "Given fasta file cannot be opend";

{

local $/ ="\n>";

while(my $line = <$fastain>){

    # Turn $/ into original.
    local $/ = "\n";

    chomp($line);
    my @head_seq = split(/\n/, $line);
    my $id = shift @head_seq;
    my $sequence = join("", @head_seq);
    chomp($sequence);
    $id =~ s/>//g; #for the first header

    my $substr_seq = substr( $sequence, 0, $length );
    my (@array, @pos_array);

    my $isSliding = $opt_slide;
    my $isSVM     = $opt_svm;

    if(!$isSliding){
        # in some sequence, there is no below motif.
        # To avoid no score case, enforcely using sliding window.
	# SVM calc is costly, so in this case turn off SVM.
        if($substr_seq !~ /[$aminoAcids]{2}R[$aminoAcids]{6}/){
            $isSliding = 1;
	    #$isSVM     = 0;
        }

    }

    if($isSliding){
        @array = &cutter( sequence   =>$sequence,
                          length     =>$length,
                          windowSize =>10 );
        my $length_of_array = @array;
        @pos_array = &seq(0,$length_of_array,1);

    }else{
        while($substr_seq =~ /(?=([$aminoAcids]{2}R[$aminoAcids]{6}))/ig){
            push @array, $1;
            push @pos_array, pos($substr_seq);
        }
    }

    print "$id\t";
    my @score_array;
    my $max;
    my $secondmax;

    # Just a charm to avoid crush.
    if(!@array){
        print "0\tNo arginine in N-terminal\n";
        next;
    }

    if($opt_gamma){
        @score_array = &WeightedScore( $matrix, \@array, \@pos_array, \@Gamma_params );
    } else {
        @score_array = &Score( $matrix, \@array );
    }

    # Apply SVM proberbilities if svm flag is true.

    # obtain indices for maximum and second maximum values in score_array
    # Note: $maxsite_pos contains not a position but a index for maximum socre.
    # To get the position, use position_hash with its key.
    my ($maxsite_pos, $secondsite_pos);

    if($isSVM){
        my @svm_probs = &svm_classify(
            Model=>$svmModelPath,
            Sequence=>$sequence,
            Score_reference=>\@score_array,
            Position_reference=>\@pos_array,
	    Prior_struct=>$struct,
            Name=>$id,
        );
        ($maxsite_pos, $secondsite_pos) = &findMax( @svm_probs );
        $maxsite_pos = $secondsite_pos if($pos_array[$maxsite_pos] < 2); # To exclude too short presequences.
        $max = $svm_probs[$maxsite_pos]; $secondmax = $svm_probs[$secondsite_pos];

    } else {
        ($maxsite_pos, $secondsite_pos) = &findMax(@score_array);
        $maxsite_pos = $secondsite_pos if($pos_array[$maxsite_pos] < 2); # To exclude too short presequences.
        $max = $score_array[$maxsite_pos]; $secondmax = $score_array[$secondsite_pos];
    }

    my @charge = &chargedResidue($sequence, $pos_array[$maxsite_pos]+3);
    my $charge = &netcharge($sequence, $pos_array[$maxsite_pos]+3);

    if($opt_mature  || $opt_metazoa){
        my $Oct1score = calculate_pwm(
            substr($sequence, $pos_array[$maxsite_pos]+$intermediate_point, 4),
            $matrix, 'Yeast_Oct1');
        my $Icp55score = calculate_pwm(
            substr($sequence, $pos_array[$maxsite_pos]+$intermediate_point, 2),
            $matrix, 'Yeast_Icp55');
        my $position = "";
        my $intermediate_protease = "";

        if($Oct1score >= $thresholdOct1){
            $position = ", ";
            # last 4 is an adjuster for making window position to preseq length.
            $position .= $pos_array[$maxsite_pos] + 8 + 4;

            $intermediate_protease = "(Oct1)";

        } elsif($Oct1score < $thresholdOct1 && $Icp55score >= $thresholdIcp55){
            $position = ", ";
            # last 4 is an adjuster for making window position to preseq length.
            $position .= $pos_array[$maxsite_pos] + 1 + 4;

            $intermediate_protease = "(Icp55)";
            # In metazoa or plant, Icp55 has not been discovered, so add asterisk.
            if($opt_metazoa){
                chop($intermediate_protease);
                $intermediate_protease.= "*)";
            }

        }

        print $max,"\t", $pos_array[$maxsite_pos] + 4,"(MPP)", $position, $intermediate_protease,
            "\t", $charge, "\t", $array[$maxsite_pos], "\t", $Oct1score, "\t", $Icp55score, "\n";

    } elsif($opt_plant) {
        my $position = "";
        my $intermediate_protease = "";

        my $R3score = calculate_pwm(
            substr($array[$maxsite_pos], $intermediate_point, 2),
            $matrix, 'Plant_Icp55Like'
            );

        if($R3score > $thresholdIcp55Like){
            $position  = ", ";
            $position .= $pos_array[$maxsite_pos] + 1 + 4;
            $intermediate_protease = "(Icp55*)";
        }

        print $max, "\t", $pos_array[$maxsite_pos] + 4, "(MPP)", $position, $intermediate_protease,
            "\t", $charge, "\t", $array[$maxsite_pos], "\t", $R3score, "\n";

    } else {

        print $max, "\t", $pos_array[$maxsite_pos], "\t",
            $array[$maxsite_pos], "\t";
        print $secondmax, "\t", $pos_array[$secondsite_pos], "\t",
            $array[$secondsite_pos], "\n";

    }

}}


## To discriminate fp cleavage, call libsvm and calculate POSTERIOR PROBABIRITY
## Arguments:
## Model              file path for libsvm's prediction model
## Sequence           aa sequence to be predicted
## Score_reference    reference to PWM score
## Position_reference the position whose Positions to be predicted. if $opt_slide, this equals to all positions 
sub svm_classify
{
    my %args = (
        Model => "",
        Sequence => "",
        Score_reference => "",
        Position_reference => "",
	Prior_struct => "",
        Name => "",
        @_
    );
    my $num;
    my @temp = split(/\//, $args{Model});
    my @score_array = @{$args{Score_reference}};
    my @prob_array;
    my @position_array = @{$args{Position_reference}};

    croak "The number of scores and that of position do not match.\n" if($#score_array != $#position_array);

    # make temp files.
    my $t_dir = File::Temp->newdir( CLEANUP=>1 );
    my $tmp = File::Temp->new( UNLINK => 1, DIR => $t_dir, SUFFIX => '.libsvm' );
    my $tmpFile = $tmp->filename;
    for(my $i=0; $i<@score_array; $i++){
        my $netCharge = &netcharge($args{Sequence}, $position_array[$i]+3);
        my @charge = &chargedResidue($args{Sequence}, $position_array[$i]+3);
        my $length = $position_array[$i]+3 >= 17 ? ($position_array[$i]+3)+1 : 18;

        my %features = (
            "R" => $charge[0],
            "K" => $charge[1],
            "D" => $charge[3],
            "E" => $charge[4],
            "negative" => $charge[3]+$charge[4],
            "positive" => $charge[0]+$charge[1],
            "netcharge" => $netCharge,
            "PWMscore" => $score_array[$i],
        );

        my ($aacomp_ref, $mean_hydrophobicity);
        my $_seq = substr($args{Sequence}, 0, $position_array[$i]+3+1);

        $features{"AAcompositions"} = Calc_aa_composition_DirichletPosterior($_seq, $args{Prior_struct}); #reference for HASH
        $features{"Hydrophobicity"} = Calc_mean_hydrophobicity(type => "ABODR", sequence=>$_seq); #SCHOLAR

        $tmp->print("1 ");
        my $counter=1;
        foreach my $each_feature (sort keys %features){
            if( ref $features{$each_feature} eq 'ARRAY'){
                foreach my $AA (@{$features{$each_feature}}){
                    $tmp->print("$counter:", $AA, " ");
                    $counter++;
                }
            }
            else {
                $tmp->print("$counter:", $features{$each_feature}, " ");
                $counter++;
            }
        }

        $tmp->print("\n");
        undef $netCharge;
        undef @charge;

    }

    my $tmpScaled = File::Temp->new( UNLINK => 1, DIR => $t_dir, SUFFIX => '_cleavage.scaled' );
    my $scaledFile = $tmpScaled->filename; #charm
    my $tmpOut = File::Temp->new( UNLINK => 1, DIR => $t_dir, SUFFIX => '.out' );
    my $tmpOutFile = $tmpOut->filename; #charm


    # scaling file for SVM
    `svm-scale -r $Bin/Setting/Cleavage.scaling $tmpFile > $scaledFile`;

    # calculate posterior probs
    `svm-predict -b 1 $scaledFile $args{Model} $tmpOutFile`;

    local $/ = "\n";
    my @lines = <$tmpOut>;
    #to skip header, start from 1.
    for(my $i=1; $i<@lines; $i++){
        chomp($lines[$i]);
        my @prob = split(/\s/, $lines[$i]);
        push @prob_array, $prob[1]; #$i is larger by one than indeces for score_array
    }
    local $/ = "\n";

    return @prob_array;
}

## Calculate PWM log odds score
## Arguments:
## key sequence ID to get sequences through hash
## hash_ref reference to hash which stores chopped sequences by the routine cutter()
sub Score
{
    if(@_ != 2){
        print STDERR "==\tScore.\n";
        print STDERR "==\tERROR: The number of arguments is incorrect.\n";
        exit(1);
    }

    my ($matrix, $array_ref) = @_;
    my @string_array = @{$array_ref};
    my @score_array;

    for(my $i=0;$i<@string_array; $i++){
        my $seq = $string_array[$i];
        my $score;
        $score = calculate_pwm($seq, $matrix,'MPP');
        push @score_array, $score;
    }

    return(@score_array);
}

sub WeightedScore
{
    if(@_ != 4){
        print STDERR "==\tWeightedScore.\n";
        print STDERR "==\tERROR: The number of arguments is incorrect.\n";
        exit(1);
    }

    my ($matrix, $string_array_ref, $pos_array_ref, $paramsRef) = @_;
    my @string_array = @{$string_array_ref};
    my @pos_array = @{$pos_array_ref};
    my @score_array;

    for(my $i=0;$i<@string_array; $i++){
        my $seq = $string_array[$i];
        my $score;
        $score = calculate_pwm($seq, $matrix, 'MPP');
        # Note: give not start position but cleavage positiion. So addes 3.
        &GammaWeighting($pos_array[$i]+3, \$score, $paramsRef);
        push @score_array, $score;

    }
    return(@score_array);
}

=pod

=head1 NAME

cleavage.pl - An clevage site predictor for typical mitochondrial presequences

=head1 SYNOPSIS

B<cleavage.pl> [I<options>] inputFasta(multi is ok)

=head1 DESCRIPTION

Cleavage site predictor for mitochondrial presequences which are cleaved by MPP, (and) Oct1 or Icp55. Although this script can predict them with only PWM, PWM+length weghting, and PWM+weighting+SVM, I recommend SVM mode (--svm option). SVM mode is slow, however, users can receive slighty better result. 

=head1 OPTIONS

=over 5

=item --gamma

Since length of presequence is informative to predict positions, we make use of pre-learned length distribution to weight PWM score.
Length distributions of presequence are distinctive, users have to choose taxon as an option e.g. --fungi.
Users can turn off this weighting option with some reasons.

=item --fungi, --metazoa, --plant

These options are mutually exclusive, so users have to choose one depending on an organism of a query sequence.
We cannot support other taxons such as amoeba due to the lack of data.

=item --svm

Cleavage site will be predicted by the pre-learned SVM model with other features besides weighted PWM score.
MitoFates uses this model as a default setting.

=item --sliding

Since presequence cleavage site of MPP has Arg in so many cases, Arg containing positions will be predicted to reduce computational times.
However, users can enforcely calculate all of positions by a simple sliding window approach with this option.
If there is no Arg, this option will be enforcely used but without SVM due to the computational cost (Arg is a characteristic feature for mitochondrial presequence, so no Arg infers low likelihood for the presequence, though).

=item --help, --man

Showing help message.

=back
    
=head1 AUTHOR

Yoshinori Fukasawa (gairoju@gmail.com)

=head1 COPYRIGHT

Copyright (C) 2014, Yoshinori Fukasawa, All rights reserved.

=cut
